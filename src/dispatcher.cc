#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <iostream>
#include <string>
#include <vector>

#include <opencv2/opencv.hpp>
#include "sugar/sugar.h"
#include "videostreamhandler.h"

using namespace cv;
using std::string;
using std::vector;
using std::cout;
using std::endl;

const char *kDirPrefix = "/media/reimondo/HDD/Workspace/Projects/gee/";
const int kCount = 10;
const int kBufferSize = 100;

// global variables
Mat g_frame;      // current frame
Mat g_frame_before;   // reserved frame
Mat g_fg_mask_MOG2;   // fg mask fg mask generated by MOG2 method
int g_keyboard;

void Dispatcher();

int main()
{
     Dispatcher();

    exit(0);
}

// Dispatcher.
//
void Dispatcher()
{
    char video_stream_addr[kBufferSize];
    // sprintf(video_stream_addr, "%s%s", kDirPrefix, "cam.sdp");
    sprintf(video_stream_addr, "%s%s", kDirPrefix, "example/videos/WP_20151002_09_40_51_Pro_lq.mp4");

    VideoStreamHandler(video_stream_addr, "192.168.3.1");


    // create Background Subtractor objects
    // g_pMOG2 = createBackgroundSubtractorMOG2(); // MOG2 approach

    //     Stage 3 - motion detect and output.
    //     update the backgroud model
    //     g_pMOG2->apply(g_frame, g_fg_mask_MOG2);
    //     get the frame number and write in on the current frame
    //     rectangle(g_frame, Point(10, 2), Point(100, 20),
    //               Scalar(255, 255, 255), -1);
    //     putText(g_frame, NumberToString<float>(cap.get(CAP_PROP_POS_FRAMES)),
    //             Point(15, 15), FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 0, 0));

    //     // find the boundary
    //     /*
    //     vector<vector<Point> > contours;
    //     vector<Vec4i> hierarchy;
    //     findContours(g_fg_mask_MOG2.clone(), contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);
    //     for (int i = 0; i < contours.size(); i++) {
    //         if (contourArea(contours[i]) < 500)
    //             continue;

    //         Rect rect(boundingRect(contours[i]));
    //         rectangle(g_frame, rect, Scalar(0, 255, 0), 2);
    //     }
    //     */

    //     // show the current frame and the fg masks
    //     imshow("Frame", g_frame);
    //     // threshold(g_fg_mask_MOG2, g_fg_mask_MOG2, 25, 255, THRESH_BINARY);
    //     // imshow("FG Mask MOG 2", g_fg_mask_MOG2);
    //     // get the input from the keyboard
    //     g_keyboard = waitKey(1);
    // }
}
